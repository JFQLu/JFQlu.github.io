<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-W8J42SQ');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>GraphX Reachable Vertices</title>
    <meta name="description" content="GraphX Reachable Vertices" />

    <link rel="stylesheet" href="css/style.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700;900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W8J42SQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <header class="header">
      <div class="header__content">
        <div class="header__logo-container">
          <div class="header__logo-img-cont">
            <img
              src="./assets/png/james_lu.png"
              alt="James Lu Logo Image"
              class="header__logo-img"
            />
          </div>
          <span class="header__logo-sub">James Lu</span>
        </div>
        <div class="header__main">
          <ul class="header__links">
            <li class="header__link-wrapper">
              <a href="./index.html" class="header__link"> Home </a>
            </li>
            <li class="header__link-wrapper">
              <a href="./index.html#about" class="header__link">About </a>
            </li>
            <li class="header__link-wrapper">
              <a href="./index.html#projects" class="header__link">
                Projects
              </a>
            </li>
            <li class="header__link-wrapper">
              <a href="./index.html#contact" class="header__link"> Contact </a>
            </li>
          </ul>
          <div class="header__main-ham-menu-cont">
            <img
              src="./assets/svg/ham-menu.svg"
              alt="hamburger menu"
              class="header__main-ham-menu"
            />
            <img
              src="./assets/svg/ham-menu-close.svg"
              alt="hamburger menu close"
              class="header__main-ham-menu-close d-none"
            />
          </div>
        </div>
      </div>
      <div class="header__sm-menu">
        <div class="header__sm-menu-content">
          <ul class="header__sm-menu-links">
            <li class="header__sm-menu-link">
              <a href="./index.html"> Home </a>
            </li>

            <li class="header__sm-menu-link">
              <a href="./index.html#about"> About </a>
            </li>

            <li class="header__sm-menu-link">
              <a href="./index.html#projects"> Projects </a>
            </li>

            <li class="header__sm-menu-link">
              <a href="./index.html#contact"> Contact </a>
            </li>
          </ul>
        </div>
      </div>
    </header>
    <!--- Hero Section
    <section class="project-cs-hero">
      <div class="project-cs-hero__content">
        <h1 class="heading-primary">Reachable Vertices in Directed Graph using GraphX</h1>
        <div class="project-cs-hero__info">
          <p class="text-primary">
            Predictive analysis and
          </p>
        </div>
        <div class="project-cs-hero__cta">
          <a href="#" class="btn btn--bg" target="_blank">Live Link</a>
        </div>
      </div>
    </section>
    --->
    <section class="project-details">
      <div class="main-container">
        <div class="project-details__content">
          <h3 class="project-details__content-project_heading">Reachable Vertices in Directed Graph using GraphX</h3>
          <!--- Hero Image
          <div class="project-details__showcase-img-cont">
            <img
              src="./assets/jpeg/network_anomaly_detection_hero_img.jpg"
              alt="Project Image Hero"
              class="project-details__showcase-img"
            />
          </div>
          ---> 
          <div class="project-details__content-main">
            <div class="project-details__desc">
              <h3 class="project-details__content-title_1">Project Overview</h3>
              <p class="project-details__desc-para">
                This project was conducted as coursework in Big Data Management (COMP9313) at UNSW. The problem states:
              </p>
              <h3 class="project-details__content-title_1">Background</h3>
              <p class="project-details__desc-para">
                "Given a directed graph, for each vertex v, compute the number of vertices that are reachable from v in the graph (including v itself if there is a path starting from v and ending at v). 
                For example, for node 0, the number of vertices that are reachable from 0 is 6, since there exists a path from node 0 to each node in the graph."
              </p>
              <p class="project-details__desc-para">
                This project requires the use of the Apache Spark big data processing framework, specifically, GraphX which provides an API for graph (vertices and edges) processing.
              </p>
              <p class="project-details__desc-para">
                GraphX extends the Spark RDD (Resilient Distributed Dataset) API to support graph processing by providing a set of graph-specific RDDs, which are distributed collections of data that can be processed in parallel. 
                These include VertexRDD, EdgeRDD, and Graph.
              </p>
              <p class="project-details__desc-para">
                The Pregel operator will be important in solving this problem. The Pregel operator performs the computation in a series of supersteps, with each superstep consisting of the following steps:
              </p>
              <p class="project-details__desc-para">
                We observe that there is 10% more neural sentiment tweets compared to the negative and positive classes which may be a potential issue biasing models toward the more prevalent class. 
                Since the difference is only 10% we will ignore this however a potential remedy for this would be to oversample the less prevelent classes or to undersample the more prevalent class.
              </p>
              <p class="project-details__desc-para">
                Now, observing tweet length distributions across sentiments,
              </p>
              <div class="div-list">
                <ol>
                  <li>
                    <p class="project-details__desc-list_ele">1. Each vertex receives the messages sent to it in the previous superstep and executes the vertex program, possibly updating its data and sending new messages to its neighbors.</p>
                  </li>
                  <li>
                    <p class="project-details__desc-list_ele">2. The messages are collected and stored in a message buffer.</p>
                  </li>
                  <li>
                    <p class="project-details__desc-list_ele">3. The vertex program of each vertex is executed again, this time using the updated message buffer.</p>
                  </li>
                </ol>
              </div>
              <p class="project-details__desc-para">
                This process is repeated until the algorithm converges or a maximum number of supersteps is reached.
              </p>
              <p class="project-details__desc-para">
                To solve our problem above we start by importing the required libraries.
              </p>
              <div class="div-code">
                <p>import org.apache.spark.SparkContext</p>
                <p>import org.apache.spark.SparkContext._</p>
                <p>import org.apache.spark.SparkConf</p>
                <p>import org.apache.spark.graphx._</p>
              </div>
              <p class="project-details__desc-para">
                Next, we must define a vertex program. This is a user-defined function that is executed on each vertex in the graph. 
                It takes as input the vertex ID, the current vertex data, and a message received by the vertex in the previous superstep, and it returns an updated vertex data. 
                Here we have the vertex program take the message (newData) and merge it with the vertex data (origData) removing duplicates, i.e. we take the union of newData and origData.
              </p>
              <div class="div-code">
                <p>// Vertex Program: merges vertex data (List[VertexId]) with message (List[VertexId]) removing duplicates </p>
                <p>def vertexProgram(id: VertexId, origData: List[VertexId], newData: List[VertexId]) : List[VertexId] = ( origData ::: newData ).distinct</p>
              </div>
              <p class="project-details__desc-para">
                We also define a mergeMsg function, this has no access to the context of any Vertex -- 
                it just takes individual messages and creates a single message which is then sent to the vertex program as newData. 
                Here we simply take the union of all messages.
              </p>
              <div class="div-code">
                <p>def mergeMsg(list1: List[VertexId], list2: List[VertexId]) : List[VertexId] = (list1 ::: list2).distinct</p>
              </div>
              <p class="project-details__desc-para">
                Finally, we define a sendMsg function, it takes as input the source and destination vertices of the edge, and it returns a message to be sent from the source vertex to the destination vertex. 
                Here we first check if the vertex is reachable from itself. We also check if there are any messages that need to be added to srcAttr.
              </p>
              <div class="div-code">
                <p>def sendMsg(triplet: EdgeTriplet[List[VertexId],Double]) : Iterator[(VertexId, List[VertexId])] = {</p>
                <p>&emsp;// Append destination vertexId with destination vertexAttribute (List[VertexId]) and save to new val</p>
                <p>&emsp;val newList = (triplet.dstId :: triplet.dstAttr).distinct</p>
                <p>&nbsp;</p>
                <p>&emsp;// Note that we are sending messages to the source vertex from the destination vertex (ie. we "flip" the direction of edges in the graph)</p>
                <p>&emsp;// If source vertex is also reachable from destination vertex then the source node can reach itself</p>
                <p>&emsp;if (triplet.srcAttr == triplet.dstAttr) {</p>
                <p>&emsp;&emsp;Iterator((triplet.srcId, newList)</p>
                <p>&emsp;// If the srcAttr list is the same length as the newList formed through recursion, then there is nothing new to add to the srcAttr list</p>
                <p>&emsp;} else if (triplet.srcAttr.intersect(newList).length != newList.length) {</p>
                <p>&emsp;&emsp;Iterator((triplet.srcId, newList))</p>
                <p>&emsp;} else {</p>
                <p>&emsp;&emsp;Iterator.empty</p>
                <p>&emsp;}</p>
                <p>}</p>
              </div>
              <p class="project-details__desc-para">
                Now we can create the main function:
              </p>
              <div class="div-code">
                <p>def main(args: Array[String]) = {</p>
                <p>&emsp;val conf = new SparkConf().setAppName("GraphX reachable vertices").setMaster("local")</p>
                <p>&emsp;val sc = new SparkContext(conf)</p>
                <p>&emsp;val inputFile = args(0)</p>
                <p>&emsp;val outputFile = args(1)</p>
                <p>&nbsp;</p>
                <p>&emsp;val edges = sc.textFile(inputFile)</p>
                <p>&emsp;// Create the graph</p>
                <p>&emsp;val edgelist = edges.map(x => x.split(" ")).map(x=> Edge(x(1).toLong, x(2).toLong, 1d))</p>
                <p>&emsp;val graph = Graph.fromEdges[Double, Double](edgelist, 0.0)</p>
                <p>&emsp;// Initialize each vertex attribute to empty list (List[VertexId]())</p>
                <p>&emsp;val initialGraph = graph.mapVertices((id, _) => List[VertexId]())</p>
                <p>&emsp;val result = initialGraph</p>
                <p>&emsp;&emsp;&emsp;&nbsp;.pregel(</p>
                <p>&emsp;&emsp;&emsp;&emsp;&nbsp;initialMsg = List.empty[VertexId],</p>
                <p>&emsp;&emsp;&emsp;&emsp;&nbsp;activeDirection = EdgeDirection.Out</p>
                <p>&emsp;&emsp;&emsp;&nbsp;)(vertexProgram, sendMsg, mergeMsg)</p>
                <p>&emsp;&emsp;&emsp;&nbsp;.mapVertices((_, neighbors) => neighbors.length).vertices.sortBy(_._1).filter(t => t._2 != Double.PositiveInfinity).map(a => a._1 + ":" + a._2).saveAsTextFile(outputFile)</p>
                <p>}</p>
              </div>
              <p class="project-details__desc-para">
                Note that input is in the format "EdgeId FromNodeId ToNodeId" and output in the format "VertexId:Number_of_reachable_vertices"
              </p>
              <h3 class="project-details__content-title_2">Takeaway:</h3>
              <p class="project-details__desc-para">
                From this project we see the power of GraphX for graph processing applications. It is useful for a wide range of applications that involve graph data, 
                such as social network analysis, recommendation systems, and fraud detection.
              </p>
            </div> 
            <div class="project-details__tools-used">
              <h3 class="project-details__content-title_1">Skills</h3>
              <div class="skills">
                <div class="skills__skill">Spark</div>
                <div class="skills__skill">Scala</div>
                <div class="skills__skill">Pregel - GraphX</div>
                <div class="skills__skill">Graph Theory</div>
              </div>
            </div>
            <!---
            <div class="project-details__links">
              <h3 class="project-details__content-title_1">See Live</h3>
              <a
                href="#"
                class="btn btn--med btn--theme project-details__links-btn"
                target="_blank"
                >Live Link</a
              >
              <a
                href="#"
                class="btn btn--med btn--theme-inv project-details__links-btn"
                target="_blank"
                >Code Link</a
              >
            </div>
            --->
          </div>
        </div>
      </div>
    </section>
    <footer class="main-footer">
      <div class="main-container">
        <div class="main-footer__upper">
          <div class="main-footer__row main-footer__row-1">
            <h2 class="heading heading-sm main-footer__heading-sm">
              <span>Social</span>
            </h2>
            <div class="main-footer__social-cont">
              <a target="_blank" rel="noreferrer" href="www.linkedin.com/in/jameslu-ds">
                <img
                  class="main-footer__icon"
                  src="./assets/png/linkedin-ico.png"
                  alt="icon"
                />
              </a>
              <!--
              <a target="_blank" rel="noreferrer" href="#">
                <img
                  class="main-footer__icon"
                  src="./assets/png/github-ico.png"
                  alt="icon"
                />
              </a>
              -->
            </div>
          </div>
          <div class="main-footer__row main-footer__row-2">
            <h4 class="heading heading-sm text-lt">James Lu</h4>
            <p class="main-footer__short-desc">
              Getting the most out of data...
            </p>
          </div>
        </div>
      </div>
    </footer>
    <script src="./index.js"></script>
  </body>
</html>
